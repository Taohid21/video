<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Snake & Ladder Pro Live</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <!-- Confetti Library for Winning Effect -->
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    
    <style>
        :root {
            --bg: #0f172a; --card: #1e293b; --text: #f8fafc; --text-sec: #94a3b8;
            --p1-color: #ef4444; --p1-glow: rgba(239, 68, 68, 0.6);
            --p2-color: #10b981; --p2-glow: rgba(16, 185, 129, 0.6);
            --accent: #3b82f6; --accent-glow: rgba(59, 130, 246, 0.5);
            --snake: #f59e0b; --ladder: #06b6d4;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Poppins', sans-serif; user-select: none; -webkit-tap-highlight-color: transparent; }
        
        body { 
            background-color: var(--bg); color: var(--text); min-height: 100dvh;
            display: flex; flex-direction: column; overflow-x: hidden; overflow-y: auto;
        }

        /* Top Bar */
        .top-bar { height: 65px; display: flex; align-items: center; justify-content: space-between; padding: 0 20px; background: rgba(30, 41, 59, 0.8); backdrop-filter: blur(10px); border-bottom: 1px solid rgba(255,255,255,0.05); z-index: 10;}
        .game-title { font-weight: 800; font-size: clamp(16px, 5vw, 20px); background: linear-gradient(45deg, #10b981, #3b82f6); -webkit-background-clip: text; -webkit-text-fill-color: transparent; letter-spacing: 1px; }
        .leave-btn { background: rgba(239, 68, 68, 0.1); color: #ef4444; border: 1px solid rgba(239, 68, 68, 0.2); padding: 8px 15px; border-radius: 12px; font-weight: 600; font-size: 14px; cursor: pointer; transition: 0.3s; }
        .leave-btn:active { transform: scale(0.95); background: #ef4444; color: white; }

        /* Game Area & Board */
        .game-area { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; padding: 15px; padding-bottom: 70px; }
        
        .turn-box { background: var(--card); padding: 10px 25px; border-radius: 30px; font-weight: 600; font-size: 14px; margin-bottom: 15px; box-shadow: 0 5px 15px rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.05); display: flex; align-items: center; gap: 10px; transition: 0.3s; text-align: center; }
        .turn-box.p1-turn { border-bottom: 3px solid var(--p1-color); box-shadow: 0 5px 15px var(--p1-glow); }
        .turn-box.p2-turn { border-bottom: 3px solid var(--p2-color); box-shadow: 0 5px 15px var(--p2-glow); }

        /* Snake & Ladder 10x10 Board */
        .board-container { background: var(--card); padding: 8px; border-radius: 10px; border: 2px solid rgba(255,255,255,0.1); box-shadow: 0 10px 30px rgba(0,0,0,0.5); width: 100%; max-width: 380px; margin-bottom: 20px;}
        .board { display: grid; grid-template-columns: repeat(10, 1fr); gap: 2px; width: 100%; background: #000; border-radius: 6px; overflow: hidden;}
        
        .cell { aspect-ratio: 1; background: #1e293b; display: flex; justify-content: center; align-items: center; position: relative; font-size: clamp(8px, 2.5vw, 11px); font-weight: bold; color: rgba(255,255,255,0.4); }
        .cell:nth-child(even) { background: #24334a; }
        .cell.snake-bg { box-shadow: inset 0 0 10px rgba(245, 158, 11, 0.3); color: var(--snake); }
        .cell.ladder-bg { box-shadow: inset 0 0 10px rgba(6, 182, 212, 0.3); color: var(--ladder); }
        
        /* Event Icons in Cells */
        .event-icon { position: absolute; font-size: clamp(10px, 3vw, 14px); opacity: 0.8; }
        .event-icon.top-left { top: 2px; left: 2px; }

        /* Player Pawns (‡¶ó‡ßÅ‡¶ü‡¶ø) */
        .pawn { width: clamp(10px, 3vw, 14px); height: clamp(10px, 3vw, 14px); border-radius: 50%; position: absolute; border: 2px solid #fff; z-index: 5; transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1); box-shadow: 0 2px 5px rgba(0,0,0,0.6); }
        .pawn.p1 { background: var(--p1-color); left: 10%; bottom: 10%; box-shadow: 0 0 8px var(--p1-glow); }
        .pawn.p2 { background: var(--p2-color); right: 10%; top: 10%; box-shadow: 0 0 8px var(--p2-glow); }

        /* Dice Action */
        .dice-container { display: flex; flex-direction: column; align-items: center; gap: 10px; width: 100%; }
        .dice-btn { background: linear-gradient(135deg, var(--accent), #8b5cf6); border: none; padding: 12px 30px; border-radius: 30px; font-weight: 800; font-size: 20px; color: white; display: flex; align-items: center; gap: 15px; cursor: pointer; box-shadow: 0 8px 20px var(--accent-glow); transition: 0.2s; border: 2px solid rgba(255,255,255,0.2); width: 80%; max-width: 250px; justify-content: center; }
        .dice-btn:active { transform: scale(0.95); box-shadow: 0 4px 10px var(--accent-glow); }
        .dice-btn:disabled { background: #334155; box-shadow: none; cursor: not-allowed; opacity: 0.6; }
        
        .dice-icon { font-size: 30px; }
        .shake { animation: diceShake 0.4s ease-in-out infinite; }
        @keyframes diceShake { 0%, 100% { transform: rotate(0deg) scale(1); } 25% { transform: rotate(-15deg) scale(1.1); } 75% { transform: rotate(15deg) scale(1.1); } }

        /* Toast Notification */
        .toast { position: fixed; top: 80px; left: 50%; transform: translateX(-50%) scale(0.8); background: rgba(0,0,0,0.8); backdrop-filter: blur(5px); color: white; padding: 10px 20px; border-radius: 20px; font-weight: 700; font-size: 14px; opacity: 0; pointer-events: none; transition: 0.3s; z-index: 100; border: 1px solid rgba(255,255,255,0.1); display: flex; align-items: center; gap: 10px; }
        .toast.show { opacity: 1; transform: translateX(-50%) scale(1); }

        /* Bottom Player Bar */
        .player-bar { height: 90px; background: rgba(30, 41, 59, 0.9); backdrop-filter: blur(10px); border-top: 1px solid rgba(255,255,255,0.05); display: flex; align-items: center; justify-content: space-between; padding: 0 15px; position: fixed; bottom: 0; left: 0; width: 100%; z-index: 20; }
        .player { display: flex; align-items: center; gap: 10px; width: 38%; }
        .p-img-box { position: relative; }
        .p-img { width: 45px; height: 45px; border-radius: 50%; object-fit: cover; border: 3px solid #333; background: #222; }
        .player.p1-side .p-img { border-color: var(--p1-color); box-shadow: 0 0 10px var(--p1-glow); }
        .player.p2-side .p-img { border-color: var(--p2-color); box-shadow: 0 0 10px var(--p2-glow); }
        .p-name { font-weight: 700; font-size: 13px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 80px; }
        .p-score { font-size: 11px; color: white; font-weight: 600; background: rgba(0,0,0,0.5); padding: 3px 8px; border-radius: 12px; display: inline-block; margin-top: 2px; }

        /* Smart Mic Button - Fixed Position */
        .mic-wrapper { position: absolute; left: 50%; transform: translateX(-50%); top: -35px; display: flex; flex-direction: column; align-items: center; z-index: 30;}
        .mic-btn { width: 60px; height: 60px; border-radius: 50%; background: var(--card); display: flex; justify-content: center; align-items: center; font-size: 22px; color: var(--text-sec); cursor: pointer; border: 4px solid var(--bg); transition: 0.3s; box-shadow: 0 5px 15px rgba(0,0,0,0.5); }
        .mic-btn.active { background: var(--accent); color: white; box-shadow: 0 0 20px var(--accent-glow); animation: micPulse 2s infinite; border-color: var(--bg); }
        .voice-status { font-size: 10px; color: var(--text-sec); font-weight: 600; margin-top: 5px; letter-spacing: 0.5px; text-transform: uppercase; background: var(--bg); padding: 2px 8px; border-radius: 10px; }
        @keyframes micPulse { 0% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.7); } 70% { box-shadow: 0 0 0 15px rgba(59, 130, 246, 0); } 100% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0); } }

        /* Overlays */
        .overlay-msg { position: fixed; top:0; left:0; width:100%; height:100%; background: rgba(15, 23, 42, 0.95); z-index: 50; display: none; flex-direction: column; justify-content: center; align-items: center; backdrop-filter: blur(8px); }
        .win-text { font-size: clamp(35px, 10vw, 50px); font-weight: 800; color: white; text-shadow: 0 10px 20px rgba(0,0,0,0.5); margin-bottom: 30px; text-align: center; }
        .action-btn { background: linear-gradient(45deg, var(--p2-color), var(--accent)); color: white; border: none; padding: 15px 35px; border-radius: 30px; font-weight: 700; font-size: 18px; cursor: pointer; box-shadow: 0 10px 25px rgba(16, 185, 129, 0.4); transition: 0.3s; display: flex; align-items: center; gap: 10px; }
        .action-btn:active { transform: scale(0.95); }
        
        #loader-screen { display: flex; }
        .spinner { width: 50px; height: 50px; border: 5px solid rgba(255,255,255,0.1); border-top-color: var(--accent); border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px; }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <!-- WebRTC Remote Audio -->
    <audio id="remote-audio" autoplay playsinline></audio>

    <div class="top-bar">
        <div class="game-title"><i class="fa-solid fa-dice" style="color:#10b981; margin-right:5px;"></i> SNAKE-PRO</div>
        <button class="leave-btn" onclick="leaveGame()"><i class="fas fa-sign-out-alt"></i> Leave</button>
    </div>

    <!-- Toast Notification for Snake/Ladder actions -->
    <div id="toast" class="toast">Event</div>

    <div class="game-area">
        <div id="turn-txt" class="turn-box">Connecting...</div>
        
        <!-- The Board will be generated via JavaScript -->
        <div class="board-container">
            <div class="board" id="board"></div>
        </div>

        <div class="dice-container">
            <button id="dice-btn" class="dice-btn" onclick="rollDice()" disabled>
                <i class="fas fa-dice-d6 dice-icon" id="dice-icon"></i>
                <span id="dice-text">Wait...</span>
            </button>
        </div>
    </div>

    <!-- End Game Overlay -->
    <div id="result-overlay" class="overlay-msg">
        <div id="result-text" class="win-text">Winner!</div>
        <button class="action-btn" onclick="requestRematch()"><i class="fas fa-redo"></i> Play Again</button>
    </div>

    <!-- Loading Overlay -->
    <div id="loader-screen" class="overlay-msg">
        <div class="spinner"></div>
        <h2 id="load-text" style="font-weight:700; text-align:center; padding: 0 20px;">Setting up match...</h2>
    </div>

    <!-- Bottom Player Stats Bar -->
    <div class="player-bar">
        <!-- Player 1 -->
        <div class="player p1-side">
            <div class="p-img-box"><img id="p1-img" src="" class="p-img"></div>
            <div>
                <div id="p1-name" class="p-name">Player 1</div>
                <div class="p-score">Cell: <span id="p1-pos">1</span></div>
            </div>
        </div>

        <!-- Mic Button -->
        <div class="mic-wrapper">
            <button class="mic-btn" id="mic-btn" onclick="toggleMic()">
                <i class="fas fa-microphone-slash"></i>
            </button>
            <div class="voice-status" id="v-stat">Voice Off</div>
        </div>

        <!-- Player 2 -->
        <div class="player p2-side" style="flex-direction: row-reverse; text-align: right;">
            <div class="p-img-box"><img id="p2-img" src="" class="p-img"></div>
            <div>
                <div id="p2-name" class="p-name">Waiting...</div>
                <div class="p-score">Cell: <span id="p2-pos">1</span></div>
            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, collection, addDoc } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

        // Firebase Config (‡¶è‡¶ï‡¶á ‡¶ï‡¶®‡¶´‡¶ø‡¶ó‡¶æ‡¶∞‡ßá‡¶∂‡¶® ‡¶∞‡¶æ‡¶ñ‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá)
        const cfg = { apiKey: "AIzaSyD_HBGuQSh_GzqrHqHbgdaoBikLZsK3Qqs", authDomain: "new-all-f99f7.firebaseapp.com", projectId: "new-all-f99f7", storageBucket: "new-all-f99f7.appspot.com", messagingSenderId: "1069748173900", appId: "1:1069748173900:web:158d6336c0f4628133c8e9" };
        const app = initializeApp(cfg);
        const auth = getAuth(app);
        const db = getFirestore(app);

        let me = null, myData = null;
        let roomId = new URLSearchParams(window.location.search).get('room') || "snake_room_123";
        let role = null; // 'P1' or 'P2'
        let isRolling = false;

        // ==========================================
        // 1. SNAKE & LADDER BOARD LOGIC
        // ==========================================
        const snakes = { 16:6, 47:26, 49:11, 56:53, 62:19, 64:60, 87:24, 93:73, 95:75, 98:78 };
        const ladders = { 1:38, 4:14, 9:31, 21:42, 28:84, 36:44, 51:67, 71:91, 80:100 };
        const diceIcons =["fa-dice-d6", "fa-dice-one", "fa-dice-two", "fa-dice-three", "fa-dice-four", "fa-dice-five", "fa-dice-six"];

        function initBoard() {
            const board = document.getElementById('board');
            let cells =[];
            // Boustrophedon (Snake Pattern) Generation 1-100
            for (let row = 9; row >= 0; row--) {
                let rowCells =[];
                for (let col = 1; col <= 10; col++) {
                    rowCells.push(row * 10 + col);
                }
                if (row % 2 !== 0) rowCells.reverse(); // Odd rows Right-to-Left
                cells.push(...rowCells);
            }

            cells.forEach(num => {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.id = `cell-${num}`;
                cell.innerText = num;

                // Mark Snakes & Ladders visually
                if (snakes[num]) {
                    cell.classList.add('snake-bg');
                    cell.innerHTML += `<span class="event-icon top-left">üêç</span>`;
                }
                if (ladders[num]) {
                    cell.classList.add('ladder-bg');
                    cell.innerHTML += `<span class="event-icon top-left" style="color:var(--ladder);">ü™ú</span>`;
                }

                // Add Pawn holders (invisible initially)
                const p1Pawn = document.createElement('div');
                p1Pawn.className = 'pawn p1'; p1Pawn.id = `p1-pawn-${num}`; p1Pawn.style.display = 'none';
                
                const p2Pawn = document.createElement('div');
                p2Pawn.className = 'pawn p2'; p2Pawn.id = `p2-pawn-${num}`; p2Pawn.style.display = 'none';

                cell.appendChild(p1Pawn);
                cell.appendChild(p2Pawn);
                board.appendChild(cell);
            });
        }
        initBoard();

        // ==========================================
        // 2. WEBRTC SETUP (Mobile Eco Fixed)
        // ==========================================
        const servers = { iceServers: [{ urls:['stun:stun1.l.google.com:19302', 'stun:stun2.l.google.com:19302'] }] };
        const pc = new RTCPeerConnection(servers);
        let localStream = null;
        let pendingIceCandidates =[];

        function createSilentTrack() {
            const ctx = new (window.AudioContext || window.webkitAudioContext)();
            const dest = ctx.createMediaStreamDestination();
            const osc = ctx.createOscillator();
            osc.connect(dest); osc.start();
            const track = dest.stream.getAudioTracks()[0];
            track.enabled = false;
            return track;
        }
        pc.addTrack(createSilentTrack());

        const remoteAudio = document.getElementById('remote-audio');
        pc.ontrack = (event) => {
            const stream = (event.streams && event.streams[0]) ? event.streams[0] : new MediaStream([event.track]);
            if (remoteAudio.srcObject !== stream) remoteAudio.srcObject = stream;
            remoteAudio.play().catch(() => {});
        };

        document.body.addEventListener('click', () => {
            if (remoteAudio.paused && remoteAudio.srcObject) remoteAudio.play().catch(() => {});
        });

        function addIceCandidateSafely(c) {
            if (pc.remoteDescription && pc.remoteDescription.type) {
                pc.addIceCandidate(new RTCIceCandidate(c)).catch(e => console.error(e));
            } else { pendingIceCandidates.push(c); }
        }
        function flushIceCandidates() {
            pendingIceCandidates.forEach(c => pc.addIceCandidate(new RTCIceCandidate(c)));
            pendingIceCandidates =[];
        }

        // ==========================================
        // 3. FIREBASE MATCHMAKING
        // ==========================================
        onAuthStateChanged(auth, async (u) => {
            if (u) {
                me = u;
                myData = (await getDoc(doc(db, "users", u.uid))).data() || { fullName: "Player", profilePic: "https://via.placeholder.com/50" };
                joinOrCreateRoom();
            } else {
                document.getElementById('load-text').innerText = "Please login first!";
            }
        });

        async function joinOrCreateRoom() {
            const roomRef = doc(db, "Game_Rooms", roomId);
            const roomSnap = await getDoc(roomRef);

            if (!roomSnap.exists() || !roomSnap.data().player1) {
                role = "P1";
                await setDoc(roomRef, {
                    player1: { uid: me.uid, name: myData.fullName, pic: myData.profilePic, pos: 1 },
                    player2: null, turn: "P1", winner: null, diceValue: null, eventMsg: null, eventId: 0
                });
                document.getElementById('load-text').innerText = "Waiting for friend to join...";
                setupWebRTCOffer(roomRef);
            } else {
                const data = roomSnap.data();
                if (data.player1.uid === me.uid) {
                    role = "P1"; 
                    document.getElementById('load-text').innerText = "Waiting for friend...";
                } else if (!data.player2 || data.player2.uid === me.uid) {
                    role = "P2";
                    await updateDoc(roomRef, {
                        player2: { uid: me.uid, name: myData.fullName, pic: myData.profilePic, pos: data.player2 ? data.player2.pos : 1 }
                    });
                    document.getElementById('loader-screen').style.display = 'none';
                    setupWebRTCAnswer(roomRef);
                } else {
                    document.getElementById('load-text').innerText = "Room is full!";
                    return;
                }
            }

            let lastEventId = 0;

            onSnapshot(roomRef, (snapshot) => {
                if (!snapshot.exists()) return;
                const d = snapshot.data();
                updateUI(d);
                if (d.player1 && d.player2) document.getElementById('loader-screen').style.display = 'none';
                
                // Show Toast Notification for Snake/Ladder if it's a new event
                if (d.eventMsg && d.eventId !== lastEventId) {
                    showToast(d.eventMsg, d.eventMsg.includes("üêç") ? 'snake' : 'ladder');
                    lastEventId = d.eventId;
                }
            });
        }

        // ==========================================
        // 4. GAME UI & LOGIC
        // ==========================================
        function updateUI(data) {
            // Update Profiles & Stats
            if (data.player1) {
                document.getElementById('p1-name').innerText = data.player1.uid === me.uid ? "You" : data.player1.name;
                document.getElementById('p1-img').src = data.player1.pic;
                document.getElementById('p1-pos').innerText = data.player1.pos;
            }
            if (data.player2) {
                document.getElementById('p2-name').innerText = data.player2.uid === me.uid ? "You" : data.player2.name;
                document.getElementById('p2-img').src = data.player2.pic;
                document.getElementById('p2-pos').innerText = data.player2.pos;
            }

            // Update Pawns on Board
            document.querySelectorAll('.pawn').forEach(p => p.style.display = 'none'); // Hide all
            if (data.player1) document.getElementById(`p1-pawn-${data.player1.pos}`).style.display = 'block';
            if (data.player2) document.getElementById(`p2-pawn-${data.player2.pos}`).style.display = 'block';

            // Dice Update
            const diceBtn = document.getElementById('dice-btn');
            const diceIcon = document.getElementById('dice-icon');
            const diceText = document.getElementById('dice-text');
            
            if (data.diceValue) {
                diceIcon.className = `fas ${diceIcons[data.diceValue]} dice-icon`;
            }

            // Turn Handling
            const turnBox = document.getElementById('turn-txt');
            turnBox.className = "turn-box " + (data.turn === 'P1' ? 'p1-turn' : 'p2-turn');
            
            if (data.winner) {
                turnBox.innerHTML = "Game Over!";
                diceBtn.disabled = true;
                showResult(data.winner, data);
            } else if (data.player1 && data.player2) {
                document.getElementById('result-overlay').style.display = 'none';
                if (data.turn === role) {
                    turnBox.innerHTML = `<i class="fa-solid fa-dice" style="color:${role==='P1'?'#ef4444':'#10b981'}"></i> Your Turn to Roll!`;
                    diceBtn.disabled = false;
                    diceText.innerText = "ROLL DICE";
                    diceBtn.style.background = "linear-gradient(135deg, var(--accent), #8b5cf6)";
                } else {
                    turnBox.innerHTML = `<i class="fas fa-hourglass-half"></i> Opponent's Turn`;
                    diceBtn.disabled = true;
                    diceText.innerText = "WAIT...";
                    diceBtn.style.background = "#334155";
                }
            }
        }

        window.rollDice = async () => {
            if (isRolling) return;
            const roomRef = doc(db, "Game_Rooms", roomId);
            const snap = await getDoc(roomRef);
            const data = snap.data();

            if (data.winner || data.turn !== role) return;
            isRolling = true;

            // UI Feedback during roll
            const diceIcon = document.getElementById('dice-icon');
            diceIcon.classList.add('shake');
            document.getElementById('dice-btn').disabled = true;

            // Simulate Dice Roll Delay
            await new Promise(r => setTimeout(r, 600)); 
            diceIcon.classList.remove('shake');

            let diceVal = Math.floor(Math.random() * 6) + 1;
            let oldPos = role === 'P1' ? data.player1.pos : data.player2.pos;
            let newPos = oldPos + diceVal;

            // Exact roll to win rule
            if (newPos > 100) newPos = oldPos; 

            let eMsg = null;
            if (snakes[newPos]) {
                newPos = snakes[newPos];
                eMsg = `${role === 'P1' ? data.player1.name : data.player2.name} got bit by a Snake! üêç`;
            } else if (ladders[newPos]) {
                newPos = ladders[newPos];
                eMsg = `${role === 'P1' ? data.player1.name : data.player2.name} climbed a Ladder! ü™ú`;
            }

            let nextTurn = role === 'P1' ? 'P2' : 'P1';
            
            // If rolls 6, gets another chance (Optional standard rule, adding it for fun!)
            if (diceVal === 6 && newPos !== 100) {
                nextTurn = role;
                eMsg = "Got a 6! Roll Again! üé≤";
            }

            let winner = null;
            if (newPos === 100) winner = role;

            let updateObj = { turn: nextTurn, diceValue: diceVal, winner: winner };
            if (eMsg) {
                updateObj.eventMsg = eMsg;
                updateObj.eventId = (data.eventId || 0) + 1;
            }

            if (role === 'P1') updateObj.player1 = { ...data.player1, pos: newPos };
            else updateObj.player2 = { ...data.player2, pos: newPos };

            await updateDoc(roomRef, updateObj);
            isRolling = false;
        };

        function showToast(msg, type) {
            const toast = document.getElementById('toast');
            toast.innerHTML = msg;
            toast.style.borderColor = type === 'snake' ? 'var(--snake)' : (type === 'ladder' ? 'var(--ladder)' : 'var(--accent)');
            toast.classList.add('show');
            setTimeout(() => { toast.classList.remove('show'); }, 3000);
        }

        function showResult(winner, data) {
            const overlay = document.getElementById('result-overlay');
            const resultText = document.getElementById('result-text');
            overlay.style.display = 'flex';

            if (winner === role) {
                resultText.innerHTML = "VICTORY! üèÜ";
                resultText.style.color = role === 'P1' ? "var(--p1-color)" : "var(--p2-color)";
                fireConfetti();
            } else {
                resultText.innerHTML = "DEFEAT üíÄ";
                resultText.style.color = "#94a3b8";
            }
        }

        window.requestRematch = async () => {
            const roomRef = doc(db, "Game_Rooms", roomId);
            const snap = await getDoc(roomRef);
            const data = snap.data();
            await updateDoc(roomRef, { 
                player1: { ...data.player1, pos: 1 }, 
                player2: { ...data.player2, pos: 1 }, 
                turn: "P1", winner: null, diceValue: null, eventMsg: null 
            });
        };

        function fireConfetti() {
            var duration = 3 * 1000; var end = Date.now() + duration;
            (function frame() {
                confetti({ particleCount: 5, angle: 60, spread: 55, origin: { x: 0 }, colors:['#ef4444', '#3b82f6'] });
                confetti({ particleCount: 5, angle: 120, spread: 55, origin: { x: 1 }, colors:['#10b981', '#fbbf24'] });
                if (Date.now() < end) requestAnimationFrame(frame);
            }());
        }

        // ==========================================
        // 5. WEBRTC VOICE CHAT CONTROL
        // ==========================================
        let isMicOn = false;
        window.toggleMic = async () => {
            const btn = document.getElementById('mic-btn');
            const stat = document.getElementById('v-stat');

            if (!localStream) {
                try {
                    localStream = await navigator.mediaDevices.getUserMedia({ 
                        audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true }, 
                        video: false 
                    });
                    const realAudioTrack = localStream.getAudioTracks()[0];
                    const senders = pc.getSenders();
                    const audioSender = senders.find(s => s.track === null || (s.track && s.track.kind === 'audio'));
                    if (audioSender) { await audioSender.replaceTrack(realAudioTrack); } 
                    else { pc.addTrack(realAudioTrack, localStream); }
                } catch (err) {
                    alert("Microphone access denied! " + err.message);
                    return;
                }
            }

            isMicOn = !isMicOn;
            localStream.getAudioTracks()[0].enabled = isMicOn;

            if (isMicOn) {
                btn.classList.add('active');
                btn.innerHTML = '<i class="fas fa-microphone"></i>';
                stat.innerText = "Live Chat";
                stat.style.color = "var(--accent)";
            } else {
                btn.classList.remove('active');
                btn.innerHTML = '<i class="fas fa-microphone-slash"></i>';
                stat.innerText = "Voice Off";
                stat.style.color = "var(--text-sec)";
            }
        };

        async function setupWebRTCOffer(roomRef) {
            const callerCandidates = collection(roomRef, "callerCandidates");
            pc.onicecandidate = event => { if (event.candidate) addDoc(callerCandidates, event.candidate.toJSON()); };

            const offerDescription = await pc.createOffer();
            await pc.setLocalDescription(offerDescription);
            await updateDoc(roomRef, { offer: { type: offerDescription.type, sdp: offerDescription.sdp } });

            onSnapshot(roomRef, async (snapshot) => {
                const data = snapshot.data();
                if (data && data.answer && !pc.currentRemoteDescription) {
                    await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
                    flushIceCandidates();
                }
            });

            onSnapshot(collection(roomRef, "calleeCandidates"), snapshot => {
                snapshot.docChanges().forEach(change => { if (change.type === "added") addIceCandidateSafely(change.doc.data()); });
            });
        }

        async function setupWebRTCAnswer(roomRef) {
            const calleeCandidates = collection(roomRef, "calleeCandidates");
            pc.onicecandidate = event => { if (event.candidate) addDoc(calleeCandidates, event.candidate.toJSON()); };

            onSnapshot(roomRef, async (snapshot) => {
                const data = snapshot.data();
                if (data && data.offer && !pc.currentRemoteDescription) {
                    await pc.setRemoteDescription(new RTCSessionDescription(data.offer));
                    flushIceCandidates();
                    const answerDescription = await pc.createAnswer();
                    await pc.setLocalDescription(answerDescription);
                    await updateDoc(roomRef, { answer: { type: answerDescription.type, sdp: answerDescription.sdp } });
                }
            });

            onSnapshot(collection(roomRef, "callerCandidates"), snapshot => {
                snapshot.docChanges().forEach(change => { if (change.type === "added") addIceCandidateSafely(change.doc.data()); });
            });
        }

        window.leaveGame = () => {
            if(confirm("Exit the game room?")) {
                if(localStream) localStream.getTracks().forEach(track => track.stop());
                pc.close();
                window.parent.postMessage("leave_game", "*");
            }
        };                                                                            
    </script>
</body>
</html>
