<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Messenger Pro</title>
    <link href="https://fonts.googleapis.com/css2?family=Segoe+UI:wght@300;400;600&family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <style>
        :root { --primary: #0084ff; --bg: #ffffff; --text: #050505; --bubble-sent: #0084ff; --bubble-rec: #f0f0f0; --input-bg: #f0f2f5; --gray: #65676b; }
        body.dark-mode { --primary: #0084ff; --bg: #000000; --text: #e4e6eb; --bubble-sent: #0084ff; --bubble-rec: #303030; --input-bg: #1f1f1f; --gray: #b0b3b8; }
        
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', 'Roboto', sans-serif; -webkit-tap-highlight-color: transparent; outline: none; }
        body { background-color: var(--bg); color: var(--text); height: 100vh; overflow: hidden; display: flex; flex-direction: column; }

        /* HEADER */
        .chat-head { height: 60px; display: flex; align-items: center; padding: 0 10px; box-shadow: 0 1px 2px rgba(0,0,0,0.1); flex-shrink: 0; justify-content: space-between; background: var(--bg); z-index: 20; }
        .head-left { display: flex; align-items: center; gap: 8px; }
        .back-btn { font-size: 24px; color: var(--primary); padding: 8px; cursor: pointer; }
        .u-ava { width: 40px; height: 40px; border-radius: 50%; object-fit: cover; background: #ddd; border: 1px solid rgba(0,0,0,0.1); }
        .u-info { display: flex; flex-direction: column; }
        .u-nm { font-weight: 600; font-size: 16px; }
        .u-st { font-size: 12px; color: var(--gray); }
        .head-act i { font-size: 22px; color: var(--primary); padding: 10px; cursor: pointer; }

        /* INBOX */
        #inbox-view { width: 100%; height: 100%; position: absolute; background: var(--bg); z-index: 10; display: flex; flex-direction: column; }
        .ib-header { padding: 15px; font-size: 24px; font-weight: 800; }
        .ib-list { flex: 1; overflow-y: auto; }
        .ib-item { display: flex; gap: 12px; padding: 10px 15px; cursor: pointer; border-radius: 10px; margin: 0 5px; }
        .ib-item:active { background: rgba(0,0,0,0.05); }
        .ib-det { flex: 1; display: flex; flex-direction: column; justify-content: center; }
        .ib-n { font-weight: 600; font-size: 16px; }
        .ib-m { font-size: 14px; color: var(--gray); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 250px; }

        /* CHAT AREA */
        #chat-interface { width: 100%; height: 100%; display: none; flex-direction: column; background: var(--bg); position: absolute; z-index: 15; }
        #msg-area { flex: 1; overflow-y: auto; padding: 10px; display: flex; flex-direction: column; gap: 4px; padding-bottom: 10px; }
        
        .msg-row { display: flex; flex-direction: column; max-width: 75%; position: relative; margin-bottom: 2px; }
        .msg-row.sent { align-self: flex-end; align-items: flex-end; }
        .msg-row.rec { align-self: flex-start; align-items: flex-start; }
        
        /* Reply Context Style */
        .reply-ctx { font-size: 11px; color: #888; background: rgba(0,0,0,0.05); padding: 4px 8px; border-radius: 8px; margin-bottom: -5px; z-index: 0; width: fit-content; max-width: 100%; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; transform: scale(0.9); transform-origin: inherit; }
        .sent .reply-ctx { align-self: flex-end; transform-origin: bottom right; }

        .msg-bub { padding: 8px 12px; border-radius: 18px; font-size: 15px; line-height: 1.4; word-wrap: break-word; position: relative; z-index: 1; cursor: pointer; }
        .sent .msg-bub { background: var(--bubble-sent); color: white; border-bottom-right-radius: 4px; }
        .rec .msg-bub { background: var(--bubble-rec); color: var(--text); border-bottom-left-radius: 4px; }
        
        .msg-img, .msg-vid { width: 100%; border-radius: 12px; margin-top: 5px; cursor: pointer; }
        .dl-btn { font-size: 11px; text-decoration: none; color: inherit; opacity: 0.7; display: block; margin-top: 3px; text-align: right; }

        /* FOOTER & INPUT */
        .chat-foot { padding: 5px 10px 10px 10px; display: flex; align-items: center; gap: 8px; background: var(--bg); position: relative; }
        
        /* Reply Preview Box */
        #reply-box { position: absolute; bottom: 100%; left: 0; width: 100%; background: var(--bg); border-top: 1px solid rgba(0,0,0,0.1); padding: 8px 15px; display: none; justify-content: space-between; align-items: center; border-left: 4px solid var(--primary); }
        .rep-txt { font-size: 13px; color: var(--gray); overflow: hidden; white-space: nowrap; text-overflow: ellipsis; max-width: 80%; }

        .cf-actions i { font-size: 22px; color: var(--primary); padding: 8px; cursor: pointer; }
        .cf-in-box { flex: 1; background: var(--input-bg); border-radius: 20px; display: flex; align-items: center; padding: 8px 12px; transition: 0.2s; }
        .cf-in { background: transparent; border: none; flex: 1; outline: none; color: var(--text); font-size: 15px; max-height: 100px; }
        
        /* Voice Recorder UI */
        #rec-overlay { position: absolute; top:0; left:0; width:100%; height:100%; background: var(--bg); display: none; align-items: center; padding: 0 15px; z-index: 5; }
        .rec-wave { flex: 1; height: 30px; background: url('https://i.gifer.com/7S7F.gif'); background-size: contain; opacity: 0.5; margin: 0 15px; }
        .rec-time { font-weight: bold; color: var(--primary); min-width: 45px; }
        .rec-cancel { color: red; font-weight: 500; cursor: pointer; padding: 10px; }

        /* CALL OVERLAY */
        #call-modal { position: fixed; top:0; left:0; width:100%; height:100%; background: #222; z-index: 9999; display: none; flex-direction: column; align-items: center; padding-top: 80px; color: white; animation: slideUp 0.3s; }
        .c-u-img { width: 100px; height: 100px; border-radius: 50%; border: 2px solid rgba(255,255,255,0.2); object-fit: cover; margin-bottom: 20px; box-shadow: 0 5px 20px rgba(0,0,0,0.5); }
        .c-nm { font-size: 24px; font-weight: 600; margin-bottom: 5px; }
        .c-st { font-size: 16px; opacity: 0.7; margin-bottom: 50px; }
        
        .c-ctrls { position: absolute; bottom: 40px; width: 100%; display: flex; justify-content: center; gap: 30px; align-items: center; }
        .c-btn { width: 60px; height: 60px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 24px; cursor: pointer; transition: 0.2s; background: rgba(255,255,255,0.2); }
        .c-btn:active { transform: scale(0.9); }
        .c-end { background: #ff3b30; }
        .c-ans { background: #34c759; }
        .c-mute.active { background: white; color: black; }
        .c-btn-sm { width: 45px; height: 45px; font-size: 18px; }

        @keyframes slideUp { from{transform: translateY(100%);} to{transform: translateY(0);} }
        #loader { position: fixed; top:0; left:0; width:100%; height:100%; background: var(--bg); z-index: 100; display:flex; justify-content:center; align-items:center; }
    </style>
</head>
<body>

    <div id="loader"><i class="fas fa-circle-notch fa-spin" style="color:#0084ff;font-size:30px;"></i></div>

    <!-- INBOX -->
    <div id="inbox-view">
        <div class="ib-header">Chats</div>
        <div class="ib-list" id="chat-list"></div>
        <div style="position:fixed; bottom:20px; right:20px; width:55px; height:55px; background:var(--primary); border-radius:50%; color:white; display:flex; align-items:center; justify-content:center; box-shadow:0 4px 10px rgba(0,132,255,0.4); cursor:pointer;" onclick="openFriends()"><i class="fas fa-edit"></i></div>
    </div>

    <!-- FRIEND SELECTOR MODAL -->
    <div id="fr-modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:var(--bg); z-index:30; flex-direction:column;">
        <div class="chat-head"><span class="u-nm">New Message</span><span style="color:var(--primary); cursor:pointer;" onclick="document.getElementById('fr-modal').style.display='none'">Cancel</span></div>
        <div class="ib-list" id="fr-list"></div>
    </div>

    <!-- CHAT INTERFACE -->
    <div id="chat-interface">
        <div class="chat-head">
            <div class="head-left">
                <i class="fas fa-arrow-left back-btn" onclick="closeChat()"></i>
                <img id="c-ava" class="u-ava">
                <div class="u-info">
                    <div id="c-name" class="u-nm">User</div>
                    <div class="u-st">Active now</div>
                </div>
            </div>
            <div class="head-act">
                <i class="fas fa-phone-alt" onclick="startCall()"></i>
                <i class="fas fa-video"></i>
            </div>
        </div>
        
        <div id="msg-area"></div>
        
        <!-- Reply Preview -->
        <div class="chat-foot">
            <div id="reply-box">
                <div>
                    <div style="font-size:11px; color:var(--primary); font-weight:600;">Replying to</div>
                    <div id="rep-txt" class="rep-txt">Message text...</div>
                </div>
                <i class="fas fa-times" style="color:#888; cursor:pointer;" onclick="cancelReply()"></i>
            </div>

            <!-- Normal Inputs -->
            <div class="cf-actions" id="std-act">
                <i class="fas fa-image" onclick="document.getElementById('media-in').click()"></i>
            </div>
            <input type="file" id="media-in" hidden accept="image/*,video/*" onchange="uploadMedia(this)">
            
            <div class="cf-in-box">
                <input id="msg-in" class="cf-in" placeholder="Message..." onkeyup="chkTyping(this)">
            </div>
            
            <div class="cf-actions">
                <i class="fas fa-microphone" id="mic-btn" onclick="startRecord()"></i>
                <i class="fas fa-paper-plane" id="send-btn" style="display:none; color:var(--primary);" onclick="sendTxt()"></i>
            </div>

            <!-- Voice Overlay -->
            <div id="rec-overlay">
                <div class="rec-cancel" onclick="cancelRecord()">Cancel</div>
                <div class="rec-time" id="rec-timer">0:00</div>
                <div class="rec-wave"></div>
                <i class="fas fa-paper-plane" style="color:var(--primary); font-size:24px; padding:10px; cursor:pointer;" onclick="stopAndSendRecord()"></i>
            </div>
        </div>
    </div>

    <!-- CALL UI -->
    <div id="call-modal">
        <img id="call-img" class="c-u-img" src="">
        <div id="call-nm" class="c-nm">User</div>
        <div id="call-st" class="c-st">Calling...</div>
        
        <!-- Audio Element (Hidden but active) -->
        <audio id="remote-audio" autoplay></audio>

        <div class="c-ctrls">
            <div class="c-btn c-btn-sm" id="spk-btn" onclick="toggleSpk()"><i class="fas fa-volume-up"></i></div>
            
            <!-- End Call -->
            <div class="c-btn c-end" onclick="endCall()"><i class="fas fa-phone-slash"></i></div>
            
            <!-- Answer (Hidden by default) -->
            <div class="c-btn c-ans" id="ans-btn" style="display:none;" onclick="answerCall()"><i class="fas fa-phone"></i></div>

            <div class="c-btn c-btn-sm c-mute" id="mute-btn" onclick="toggleMute()"><i class="fas fa-microphone-slash"></i></div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, collection, query, orderBy, addDoc, onSnapshot, where, setDoc, serverTimestamp, updateDoc, deleteDoc } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

        // CONFIG (Replace with your own if needed, used generic placeholder)
        const cfg = { apiKey: "AIzaSyD_HBGuQSh_GzqrHqHbgdaoBikLZsK3Qqs", authDomain: "new-all-f99f7.firebaseapp.com", projectId: "new-all-f99f7", storageBucket: "new-all-f99f7.appspot.com", messagingSenderId: "1069748173900", appId: "1:1069748173900:web:158d6336c0f4628133c8e9" };
        const C_URL = "https://api.cloudinary.com/v1_1/dwgvvzbvn/auto/upload";
        const C_PRE = "storyapp"; 

        const app = initializeApp(cfg);
        const auth = getAuth(app);
        const db = getFirestore(app);

        let me = null;
        let chatId = null;
        let otherUser = null;
        let replyData = null; // { id, txt, senderName }
        
        // Audio / Recorder vars
        let mediaRecorder = null;
        let audioChunks = [];
        let recInterval = null;

        // Call Vars
        let pc = null;
        let localStream = null;
        let incomingCallId = null;
        let isMuted = false;
        
        const servers = { iceServers: [{ urls: ['stun:stun1.l.google.com:19302', 'stun:stun2.l.google.com:19302'] }] };

        onAuthStateChanged(auth, async (u) => {
            if(u) {
                me = u;
                document.getElementById('loader').style.display = 'none';
                loadInbox();
                listenGlobalCalls();
            } else {
                location.href = "Account.html";
            }
        });

        // --- INBOX ---
        function loadInbox() {
            const q = query(collection(db, "chats"), where("users", "array-contains", me.uid));
            onSnapshot(q, (snap) => {
                const list = document.getElementById('chat-list');
                list.innerHTML = "";
                let chats = [];
                snap.forEach(d => chats.push({id: d.id, ...d.data()}));
                chats.sort((a, b) => (b.lastMsgTime?.toMillis() || 0) - (a.lastMsgTime?.toMillis() || 0));
                
                chats.forEach(d => {
                    const oid = d.users.find(id => id !== me.uid);
                    const info = d.userInfo && d.userInfo[oid] ? d.userInfo[oid] : {name: "Unknown", pic: ""};
                    const isBold = (d.lastMsgSender !== me.uid && !d.seen) ? "font-weight:700;color:var(--text)" : "";
                    list.innerHTML += `<div class="ib-item" onclick="startChat('${oid}')"><img src="${info.pic}" class="u-ava"><div class="ib-det"><div class="ib-n">${info.name}</div><div class="ib-m" style="${isBold}">${d.lastMsgSender === me.uid ? 'You: ' : ''}${d.lastMsg}</div></div></div>`;
                });
            });
        }

        window.openFriends = async () => {
            document.getElementById('fr-modal').style.display = 'flex';
            const list = document.getElementById('fr-list');
            list.innerHTML = '<div style="padding:20px;text-align:center">Loading...</div>';
            const d = await getDoc(doc(db,"users",me.uid));
            const fr = d.data().friends || [];
            list.innerHTML = "";
            for(const id of fr) {
                const f = (await getDoc(doc(db,"users",id))).data();
                list.innerHTML += `<div class="ib-item" onclick="startChat('${id}');document.getElementById('fr-modal').style.display='none'"><img src="${f.profilePic}" class="u-ava"><div class="ib-det"><div class="ib-n">${f.fullName}</div></div></div>`;
            }
        }

        // --- CHAT LOGIC ---
        window.startChat = async (uid) => {
            document.getElementById('inbox-view').style.display = 'none';
            document.getElementById('chat-interface').style.display = 'flex';
            
            const u = (await getDoc(doc(db,"users",uid))).data();
            otherUser = { uid: uid, name: u.fullName, pic: u.profilePic };
            document.getElementById('c-name').innerText = u.fullName;
            document.getElementById('c-ava').src = u.profilePic;
            
            chatId = me.uid < uid ? `${me.uid}_${uid}` : `${uid}_${me.uid}`;
            
            const q = query(collection(db, "chats", chatId, "messages"), orderBy("time", "asc"));
            onSnapshot(q, (snap) => {
                const area = document.getElementById('msg-area');
                area.innerHTML = "";
                snap.forEach(d => renderMsg(d.data(), d.id, area));
                area.scrollTop = area.scrollHeight;
            });
        }

        function renderMsg(m, id, area) {
            const isMe = m.sender === me.uid;
            const cls = isMe ? 'sent' : 'rec';
            
            let content = '';
            
            // Check Reply
            let replyBlock = '';
            if(m.replyTo) {
                replyBlock = `<div class="reply-ctx"><i class="fas fa-share" style="margin-right:4px"></i> ${m.replyTo.txt}</div>`;
            }

            if(m.type === 'text') content = `<div class="msg-bub" onclick="setReply('${m.txt}', '${m.sender}')" oncontextmenu="setReply('${m.txt}', '${m.sender}'); return false;">${m.txt}</div>`;
            else if(m.type === 'image') content = `<img src="${m.url}" class="msg-img" onclick="window.open('${m.url}', '_blank')"><a href="${m.url}" download class="dl-btn">Save Image</a>`;
            else if(m.type === 'video') content = `<video src="${m.url}" controls class="msg-vid"></video><a href="${m.url}" download class="dl-btn">Save Video</a>`;
            else if(m.type === 'audio') content = `<audio src="${m.url}" controls style="height:40px; border-radius:20px; margin-top:5px; max-width:200px;"></audio>`;

            area.innerHTML += `<div class="msg-row ${cls}">${replyBlock}${content}</div>`;
        }

        // --- REPLY SYSTEM ---
        window.setReply = (txt, senderId) => {
            replyData = { txt: txt, sender: senderId };
            document.getElementById('reply-box').style.display = 'flex';
            document.getElementById('rep-txt').innerText = txt;
            document.getElementById('msg-in').focus();
        }

        window.cancelReply = () => {
            replyData = null;
            document.getElementById('reply-box').style.display = 'none';
        }

        window.chkTyping = (el) => {
            const hasTxt = el.value.trim().length > 0;
            document.getElementById('send-btn').style.display = hasTxt ? 'block' : 'none';
            document.getElementById('mic-btn').style.display = hasTxt ? 'none' : 'block';
            document.getElementById('std-act').style.display = hasTxt ? 'none' : 'flex';
        }

        window.sendTxt = async () => {
            const inp = document.getElementById('msg-in');
            const txt = inp.value.trim();
            if(!txt) return;
            inp.value = "";
            chkTyping(inp);
            
            const payload = { sender: me.uid, txt: txt, type: 'text', time: serverTimestamp() };
            if(replyData) {
                payload.replyTo = { txt: replyData.txt };
                cancelReply();
            }
            
            await pushMsg(payload);
        }

        // --- VOICE RECORDER ---
        window.startRecord = async () => {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream);
                audioChunks = [];
                
                document.getElementById('rec-overlay').style.display = 'flex';
                let sec = 0;
                recInterval = setInterval(() => {
                    sec++;
                    let m = Math.floor(sec/60);
                    let s = sec%60;
                    document.getElementById('rec-timer').innerText = `${m}:${s<10?'0':''}${s}`;
                }, 1000);

                mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
                mediaRecorder.start();
            } catch(e) { alert("Mic permission denied"); }
        }

        window.cancelRecord = () => {
            if(mediaRecorder) mediaRecorder.stop();
            resetRecUI();
            audioChunks = []; // discard
        }

        window.stopAndSendRecord = () => {
            if(!mediaRecorder) return;
            mediaRecorder.onstop = async () => {
                const blob = new Blob(audioChunks, { type: 'audio/webm' });
                await uploadAndSend(blob, 'audio', 'voice.webm');
                resetRecUI();
            };
            mediaRecorder.stop();
        }

        function resetRecUI() {
            document.getElementById('rec-overlay').style.display = 'none';
            clearInterval(recInterval);
            document.getElementById('rec-timer').innerText = "0:00";
            if(mediaRecorder && mediaRecorder.stream) mediaRecorder.stream.getTracks().forEach(t=>t.stop());
        }

        window.uploadMedia = async (inp) => {
            if(inp.files && inp.files[0]) {
                const f = inp.files[0];
                const type = f.type.startsWith('video') ? 'video' : 'image';
                await uploadAndSend(f, type, f.name);
            }
        }

        async function uploadAndSend(file, type, name) {
            const fd = new FormData(); 
            fd.append('file', file); 
            fd.append('upload_preset', C_PRE);
            
            // Cloudinary upload
            const r = await fetch(C_URL, {method:'POST', body:fd});
            const d = await r.json();
            
            await pushMsg({ sender: me.uid, txt: (type==='audio'?'Voice Message':type), type: type, url: d.secure_url, time: serverTimestamp() });
        }

        async function pushMsg(data) {
            await addDoc(collection(db, "chats", chatId, "messages"), data);
            
            const myInfo = (await getDoc(doc(db, "users", me.uid))).data();
            await setDoc(doc(db, "chats", chatId), {
                users: [me.uid, otherUser.uid], 
                lastMsg: data.txt, 
                lastMsgSender: me.uid,
                seen: false,
                lastMsgTime: serverTimestamp(),
                userInfo: { 
                    [me.uid]: { name: myInfo.fullName, pic: myInfo.profilePic }, 
                    [otherUser.uid]: { name: otherUser.name, pic: otherUser.pic } 
                }
            }, { merge: true });
        }

        window.closeChat = () => {
            document.getElementById('chat-interface').style.display = 'none';
            document.getElementById('inbox-view').style.display = 'flex';
        }

        // --- CALL SYSTEM (With ICE Candidate Fix) ---

        function showCallUI(name, pic, status, isIncoming) {
            document.getElementById('call-modal').style.display = 'flex';
            document.getElementById('call-nm').innerText = name;
            document.getElementById('call-img').src = pic;
            document.getElementById('call-st').innerText = status;
            document.getElementById('ans-btn').style.display = isIncoming ? 'flex' : 'none';
            document.getElementById('spk-btn').style.display = 'flex'; // Reset buttons
        }

        window.startCall = async () => {
            showCallUI(otherUser.name, otherUser.pic, "Calling...", false);
            
            pc = new RTCPeerConnection(servers);
            localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
            localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

            pc.ontrack = (event) => {
                const remoteAudio = document.getElementById('remote-audio');
                remoteAudio.srcObject = event.streams[0];
            };

            // ICE Candidate Handling (Sender)
            const callDoc = doc(collection(db, "calls")); // Create new ID
            const offerCandidates = collection(db, "calls", callDoc.id, "offerCandidates");
            const answerCandidates = collection(db, "calls", callDoc.id, "answerCandidates");

            pc.onicecandidate = (event) => {
                if(event.candidate) addDoc(offerCandidates, event.candidate.toJSON());
            };

            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);

            await setDoc(callDoc, {
                offer: { type: offer.type, sdp: offer.sdp },
                callerId: me.uid,
                receiverId: otherUser.uid,
                status: 'calling'
            });
            incomingCallId = callDoc.id; // Store temp ID

            // Listen for Answer
            onSnapshot(callDoc, (snap) => {
                const data = snap.data();
                if(!pc || !data) return;
                
                if(data.answer && !pc.currentRemoteDescription) {
                    const rtcSessionDescription = new RTCSessionDescription(data.answer);
                    pc.setRemoteDescription(rtcSessionDescription);
                    document.getElementById('call-st').innerText = "Connected";
                }
                if(data.status === 'ended') endCallCleanup();
            });

            // Listen for Callee Candidates
            onSnapshot(answerCandidates, (snap) => {
                snap.docChanges().forEach((change) => {
                    if (change.type === 'added') {
                        const candidate = new RTCIceCandidate(change.doc.data());
                        pc.addIceCandidate(candidate);
                    }
                });
            });
        }

        function listenGlobalCalls() {
            const q = query(collection(db, "calls"), where("receiverId", "==", me.uid), where("status", "==", "calling"));
            onSnapshot(q, async (snap) => {
                snap.docChanges().forEach(async (change) => {
                    if(change.type === 'added') {
                        const d = change.doc.data();
                        incomingCallId = change.doc.id;
                        
                        // Get caller info
                        const cUser = (await getDoc(doc(db, "users", d.callerId))).data();
                        showCallUI(cUser.fullName, cUser.profilePic, "Incoming Audio Call", true);
                    }
                });
            });
            
            // Listen for ends on general
            const qEnd = query(collection(db, "calls"), where("receiverId", "==", me.uid));
            onSnapshot(qEnd, (snap) => {
                 snap.docChanges().forEach(change => {
                     if(change.type === 'modified' && change.doc.data().status === 'ended') {
                         if(document.getElementById('call-modal').style.display === 'flex') endCallCleanup();
                     }
                 });
            });
        }

        window.answerCall = async () => {
            const callId = incomingCallId;
            const callDoc = doc(db, "calls", callId);
            const answerCandidates = collection(db, "calls", callId, "answerCandidates");
            const offerCandidates = collection(db, "calls", callId, "offerCandidates");

            pc = new RTCPeerConnection(servers);
            localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
            localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

            pc.ontrack = (event) => {
                document.getElementById('remote-audio').srcObject = event.streams[0];
            };

            pc.onicecandidate = (event) => {
                if(event.candidate) addDoc(answerCandidates, event.candidate.toJSON());
            };

            const callData = (await getDoc(callDoc)).data();
            await pc.setRemoteDescription(new RTCSessionDescription(callData.offer));

            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);

            await updateDoc(callDoc, { answer: { type: answer.type, sdp: answer.sdp }, status: 'connected' });

            // Listen for Offer Candidates (ICE)
            onSnapshot(offerCandidates, (snap) => {
                snap.docChanges().forEach((change) => {
                    if (change.type === 'added') {
                        const candidate = new RTCIceCandidate(change.doc.data());
                        pc.addIceCandidate(candidate);
                    }
                });
            });

            document.getElementById('ans-btn').style.display = 'none';
            document.getElementById('call-st').innerText = "Connected";
        }

        window.endCall = async () => {
            if(incomingCallId) {
                await updateDoc(doc(db, "calls", incomingCallId), { status: 'ended' });
            }
            endCallCleanup();
        }

        function endCallCleanup() {
            document.getElementById('call-modal').style.display = 'none';
            if(pc) { pc.close(); pc = null; }
            if(localStream) { localStream.getTracks().forEach(t => t.stop()); localStream = null; }
            incomingCallId = null;
        }

        window.toggleMute = () => {
            if(localStream) {
                isMuted = !isMuted;
                localStream.getAudioTracks()[0].enabled = !isMuted;
                document.getElementById('mute-btn').classList.toggle('active');
            }
        }
        
        window.toggleSpk = () => {
            // Note: Mobile browsers handle Speaker routing automatically or via OS. 
            // setSinkId is mostly desktop chrome supported, but we add visual feedback.
            alert("Please toggle Speakerphone from your system menu or notification tray.");
        }

    </script>
</body>
</html>
