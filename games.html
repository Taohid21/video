<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tic-Tac-Toe Pro Live</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <!-- Confetti Library for Winning Effect -->
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    
    <style>
        :root {
            --bg: #0f172a; --card: #1e293b; --text: #f8fafc; --text-sec: #94a3b8;
            --x-color: #ef4444; --x-glow: rgba(239, 68, 68, 0.4);
            --o-color: #10b981; --o-glow: rgba(16, 185, 129, 0.4);
            --accent: #3b82f6;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Poppins', sans-serif; user-select: none; -webkit-tap-highlight-color: transparent; }
        body { background-color: var(--bg); color: var(--text); height: 100vh; display: flex; flex-direction: column; overflow: hidden; }

        /* Modern Top Bar */
        .top-bar { height: 65px; display: flex; align-items: center; justify-content: space-between; padding: 0 20px; background: rgba(30, 41, 59, 0.8); backdrop-filter: blur(10px); border-bottom: 1px solid rgba(255,255,255,0.05); z-index: 10;}
        .game-title { font-weight: 800; font-size: 20px; background: linear-gradient(45deg, #3b82f6, #8b5cf6); -webkit-background-clip: text; -webkit-text-fill-color: transparent; letter-spacing: 1px; }
        .leave-btn { background: rgba(239, 68, 68, 0.1); color: #ef4444; border: 1px solid rgba(239, 68, 68, 0.2); padding: 8px 18px; border-radius: 12px; font-weight: 600; cursor: pointer; transition: 0.3s; }
        .leave-btn:active { transform: scale(0.95); background: #ef4444; color: white; }

        /* Game Area */
        .game-area { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; position: relative; padding: 20px; }
        
        .turn-box { background: var(--card); padding: 12px 30px; border-radius: 30px; font-weight: 600; font-size: 16px; margin-bottom: 30px; box-shadow: 0 10px 25px rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.05); display: flex; align-items: center; gap: 10px; transition: 0.3s; }
        .turn-box.x-turn { border-bottom: 3px solid var(--x-color); box-shadow: 0 10px 25px var(--x-glow); }
        .turn-box.o-turn { border-bottom: 3px solid var(--o-color); box-shadow: 0 10px 25px var(--o-glow); }

        /* Neon Board */
        .board { display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; width: 100%; max-width: 340px; }
        .cell { width: 100%; aspect-ratio: 1; background: rgba(30, 41, 59, 0.5); border-radius: 20px; display: flex; justify-content: center; align-items: center; font-size: 70px; font-weight: 800; cursor: pointer; transition: 0.3s; border: 2px solid rgba(255,255,255,0.05); box-shadow: inset 0 4px 10px rgba(0,0,0,0.2); }
        .cell:active { transform: scale(0.95); }
        .cell.x { color: var(--x-color); text-shadow: 0 0 20px var(--x-glow); animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        .cell.o { color: var(--o-color); text-shadow: 0 0 20px var(--o-glow); animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        @keyframes popIn { 0% { transform: scale(0.5); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }

        /* Player Stats (Bottom Bar) */
        .player-bar { height: 100px; background: rgba(30, 41, 59, 0.9); backdrop-filter: blur(10px); border-top: 1px solid rgba(255,255,255,0.05); display: flex; align-items: center; justify-content: space-between; padding: 0 20px; position: relative; padding-bottom: 10px; }
        .player { display: flex; align-items: center; gap: 12px; width: 35%; }
        .p-img-box { position: relative; }
        .p-img { width: 50px; height: 50px; border-radius: 50%; object-fit: cover; border: 3px solid #333; background: #222; }
        .player.x-side .p-img { border-color: var(--x-color); box-shadow: 0 0 15px var(--x-glow); }
        .player.o-side .p-img { border-color: var(--o-color); box-shadow: 0 0 15px var(--o-glow); }
        .p-name { font-weight: 700; font-size: 14px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 90px; }
        .p-score { font-size: 12px; color: var(--text-sec); font-weight: 600; background: rgba(0,0,0,0.3); padding: 2px 8px; border-radius: 10px; display: inline-block; margin-top: 4px; }

        /* Smart Mic Button */
        .mic-wrapper { position: absolute; left: 50%; transform: translateX(-50%); top: -35px; display: flex; flex-direction: column; align-items: center; }
        .mic-btn { width: 70px; height: 70px; border-radius: 50%; background: var(--card); display: flex; justify-content: center; align-items: center; font-size: 26px; color: var(--text-sec); cursor: pointer; border: 4px solid var(--bg); transition: 0.3s; box-shadow: 0 5px 15px rgba(0,0,0,0.5); z-index: 20; }
        .mic-btn.active { background: var(--accent); color: white; box-shadow: 0 0 25px rgba(59, 130, 246, 0.6); animation: micPulse 2s infinite; border-color: var(--bg); }
        .voice-status { font-size: 10px; color: var(--text-sec); font-weight: 600; margin-top: 5px; letter-spacing: 1px; text-transform: uppercase; }
        @keyframes micPulse { 0% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.7); } 70% { box-shadow: 0 0 0 20px rgba(59, 130, 246, 0); } 100% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0); } }

        /* Fullscreen Overlay Messages */
        .overlay-msg { position: absolute; top:0; left:0; width:100%; height:100%; background: rgba(15, 23, 42, 0.9); z-index: 50; display: none; flex-direction: column; justify-content: center; align-items: center; backdrop-filter: blur(8px); }
        .win-text { font-size: 45px; font-weight: 800; color: white; text-shadow: 0 10px 20px rgba(0,0,0,0.5); margin-bottom: 30px; text-align: center; }
        .action-btn { background: linear-gradient(45deg, var(--accent), #8b5cf6); color: white; border: none; padding: 15px 35px; border-radius: 30px; font-weight: 700; font-size: 18px; cursor: pointer; box-shadow: 0 10px 25px rgba(59, 130, 246, 0.4); transition: 0.3s; display: flex; align-items: center; gap: 10px; }
        .action-btn:active { transform: scale(0.95); }
        
        #loader-screen { display: flex; }
        .spinner { width: 50px; height: 50px; border: 5px solid rgba(255,255,255,0.1); border-top-color: var(--accent); border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px; }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <!-- Hidden Audio element to play opponent's voice -->
    <audio id="remote-audio" autoplay playsinline></audio>

    <div class="top-bar">
        <div class="game-title"><i class="fas fa-bolt" style="color:#fbbf24; margin-right:5px;"></i> TIC-TAC-PRO</div>
        <button class="leave-btn" onclick="leaveGame()"><i class="fas fa-sign-out-alt"></i> Leave</button>
    </div>

    <div class="game-area">
        <div id="turn-txt" class="turn-box">Connecting to Server...</div>
        
        <div class="board" id="board">
            <div class="cell" onclick="makeMove(0)"></div>
            <div class="cell" onclick="makeMove(1)"></div>
            <div class="cell" onclick="makeMove(2)"></div>
            <div class="cell" onclick="makeMove(3)"></div>
            <div class="cell" onclick="makeMove(4)"></div>
            <div class="cell" onclick="makeMove(5)"></div>
            <div class="cell" onclick="makeMove(6)"></div>
            <div class="cell" onclick="makeMove(7)"></div>
            <div class="cell" onclick="makeMove(8)"></div>
        </div>

        <!-- Result / Winner Overlay -->
        <div id="result-overlay" class="overlay-msg">
            <div id="result-text" class="win-text">Winner!</div>
            <button class="action-btn" onclick="requestRematch()"><i class="fas fa-redo"></i> Play Again</button>
        </div>

        <!-- Loading / Waiting Overlay -->
        <div id="loader-screen" class="overlay-msg">
            <div class="spinner"></div>
            <h2 id="load-text" style="font-weight:700;">Setting up match...</h2>
        </div>
    </div>

    <div class="player-bar">
        <!-- Player 1 (X) -->
        <div class="player x-side">
            <div class="p-img-box"><img id="p1-img" src="" class="p-img"></div>
            <div>
                <div id="p1-name" class="p-name">Player 1</div>
                <div class="p-score"><span id="p1-pts">0</span> PT <span style="color:var(--x-color);font-weight:800;margin-left:5px;">X</span></div>
            </div>
        </div>

        <!-- Voice Chat Mic Control -->
        <div class="mic-wrapper">
            <button class="mic-btn" id="mic-btn" onclick="toggleMic()">
                <i class="fas fa-microphone-slash"></i>
            </button>
            <div class="voice-status" id="v-stat">Voice Off</div>
        </div>

        <!-- Player 2 (O) -->
        <div class="player o-side" style="flex-direction: row-reverse; text-align: right;">
            <div class="p-img-box"><img id="p2-img" src="" class="p-img"></div>
            <div>
                <div id="p2-name" class="p-name">Waiting...</div>
                <div class="p-score"><span style="color:var(--o-color);font-weight:800;margin-right:5px;">O</span> <span id="p2-pts">0</span> PT</div>
            </div>
        </div>
    </div>

    <script type="module">
        // Firebase Config (à¦†à¦ªà¦¨à¦¾à¦° à¦…à§à¦¯à¦¾à¦ªà§‡à¦° à¦¡à¦¾à¦Ÿà¦¾à¦¬à§‡à¦¸)
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, collection, addDoc } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

        const cfg = { apiKey: "AIzaSyD_HBGuQSh_GzqrHqHbgdaoBikLZsK3Qqs", authDomain: "new-all-f99f7.firebaseapp.com", projectId: "new-all-f99f7", storageBucket: "new-all-f99f7.appspot.com", messagingSenderId: "1069748173900", appId: "1:1069748173900:web:158d6336c0f4628133c8e9" };
        const app = initializeApp(cfg);
        const auth = getAuth(app);
        const db = getFirestore(app);

        let me = null, myData = null;
        let roomId = new URLSearchParams(window.location.search).get('room') || "test_room_123";
        let role = null; // 'X' or 'O'
        
        // WebRTC Variables (Google STUN Servers for Voice Call)
        const servers = { iceServers: [{ urls:['stun:stun1.l.google.com:19302', 'stun:stun2.l.google.com:19302'] }] };
        const pc = new RTCPeerConnection(servers);
        let localStream = null;

        // ==========================================
        // 1. INITIALIZATION & FIREBASE AUTH
        // ==========================================
        onAuthStateChanged(auth, async (u) => {
            if (u) {
                me = u;
                myData = (await getDoc(doc(db, "users", u.uid))).data();
                joinOrCreateRoom();
            } else {
                document.getElementById('load-text').innerText = "Please login first!";
            }
        });

        // ==========================================
        // 2. ROOM LOGIC (Firebase Sync)
        // ==========================================
        async function joinOrCreateRoom() {
            const roomRef = doc(db, "Game_Rooms", roomId);
            const roomSnap = await getDoc(roomRef);

            if (!roomSnap.exists() || !roomSnap.data().player1) {
                // I am Player 1 (Host - X)
                role = "X";
                await setDoc(roomRef, {
                    player1: { uid: me.uid, name: myData.fullName, pic: myData.profilePic, pts: 0 },
                    player2: null,
                    board:["", "", "", "", "", "", "", "", ""],
                    turn: "X",
                    winner: null,
                    rematchReq: 0
                });
                document.getElementById('load-text').innerText = "Waiting for friend to join...";
                setupWebRTCOffer(roomRef);
            } else {
                const data = roomSnap.data();
                if (data.player1.uid === me.uid) {
                    role = "X"; // Host re-joined
                    document.getElementById('load-text').innerText = "Reconnected. Waiting for friend...";
                } else if (!data.player2 || data.player2.uid === me.uid) {
                    // I am Player 2 (Guest - O)
                    role = "O";
                    await updateDoc(roomRef, {
                        player2: { uid: me.uid, name: myData.fullName, pic: myData.profilePic, pts: data.player2 ? data.player2.pts : 0 }
                    });
                    document.getElementById('loader-screen').style.display = 'none';
                    setupWebRTCAnswer(roomRef);
                } else {
                    document.getElementById('load-text').innerText = "Room is full!";
                    return;
                }
            }

            // Listen for Real-Time Updates
            onSnapshot(roomRef, (snapshot) => {
                if (!snapshot.exists()) return;
                const d = snapshot.data();
                updateUI(d);
                if (d.player1 && d.player2) document.getElementById('loader-screen').style.display = 'none';
            });
        }

        // ==========================================
        // 3. UI & GAMEPLAY LOGIC
        // ==========================================
        const winConditions = [[0,1,2], [3,4,5],[6,7,8], [0,3,6], [1,4,7], [2,5,8],[0,4,8], [2,4,6]];

        function updateUI(data) {
            // Update Profiles
            if (data.player1) {
                document.getElementById('p1-name').innerText = data.player1.uid === me.uid ? "You" : data.player1.name;
                document.getElementById('p1-img').src = data.player1.pic;
                document.getElementById('p1-pts').innerText = data.player1.pts;
            }
            if (data.player2) {
                document.getElementById('p2-name').innerText = data.player2.uid === me.uid ? "You" : data.player2.name;
                document.getElementById('p2-img').src = data.player2.pic;
                document.getElementById('p2-pts').innerText = data.player2.pts;
            }

            // Update Board
            const cells = document.querySelectorAll('.cell');
            data.board.forEach((val, i) => {
                cells[i].innerText = val;
                cells[i].className = "cell"; 
                if (val) cells[i].classList.add(val.toLowerCase());
            });

            // Update Turn
            const turnBox = document.getElementById('turn-txt');
            turnBox.className = "turn-box " + (data.turn === 'X' ? 'x-turn' : 'o-turn');
            
            if (data.winner) {
                turnBox.innerHTML = "Game Over!";
                showResult(data.winner, data.turn); // Passing turn just for styling context
            } else {
                document.getElementById('result-overlay').style.display = 'none';
                if (data.turn === role) {
                    turnBox.innerHTML = `<i class="fas fa-play" style="color:${role==='X'?'#ef4444':'#10b981'}"></i> Your Turn`;
                } else {
                    turnBox.innerHTML = `<i class="fas fa-hourglass-half"></i> Opponent's Turn`;
                }
            }
        }

        window.makeMove = async (index) => {
            const roomRef = doc(db, "Game_Rooms", roomId);
            const snap = await getDoc(roomRef);
            const data = snap.data();

            if (data.winner || data.turn !== role || data.board[index] !== "") return; // Not my turn or cell full

            data.board[index] = role;
            let nextTurn = role === 'X' ? 'O' : 'X';
            let winner = null;

            // Check Win
            for (let condition of winConditions) {
                const [a, b, c] = condition;
                if (data.board[a] && data.board[a] === data.board[b] && data.board[a] === data.board[c]) {
                    winner = role; break;
                }
            }
            // Check Draw
            if (!winner && !data.board.includes("")) winner = "Draw";

            // Add Points
            if (winner === 'X') data.player1.pts += 10;
            if (winner === 'O') data.player2.pts += 10;

            await updateDoc(roomRef, { board: data.board, turn: nextTurn, winner: winner, player1: data.player1, player2: data.player2 });
        };

        function showResult(winner) {
            const overlay = document.getElementById('result-overlay');
            const resultText = document.getElementById('result-text');
            overlay.style.display = 'flex';

            if (winner === "Draw") {
                resultText.innerHTML = "Draw Match! ðŸ¤";
                resultText.style.color = "#f8fafc";
            } else if (winner === role) {
                resultText.innerHTML = "VICTORY! ðŸ†";
                resultText.style.color = role === 'X' ? "#ef4444" : "#10b981";
                fireConfetti();
            } else {
                resultText.innerHTML = "DEFEAT ðŸ’€";
                resultText.style.color = "#94a3b8";
            }
        }

        window.requestRematch = async () => {
            const roomRef = doc(db, "Game_Rooms", roomId);
            await updateDoc(roomRef, {
                board:["", "", "", "", "", "", "", "", ""],
                turn: "X",
                winner: null
            });
        };

        // Confetti Effect
        function fireConfetti() {
            var duration = 3 * 1000;
            var end = Date.now() + duration;
            (function frame() {
                confetti({ particleCount: 5, angle: 60, spread: 55, origin: { x: 0 }, colors: ['#ef4444', '#3b82f6'] });
                confetti({ particleCount: 5, angle: 120, spread: 55, origin: { x: 1 }, colors:['#10b981', '#fbbf24'] });
                if (Date.now() < end) requestAnimationFrame(frame);
            }());
        }

        // ==========================================
        // 4. WEBRTC VOICE CHAT (LIVE AUDIO)
        // ==========================================
        let isMicOn = false;

        window.toggleMic = async () => {
            const btn = document.getElementById('mic-btn');
            const stat = document.getElementById('v-stat');

            if (!localStream) {
                try {
                    // Ask for Mic Permission
                    localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                    localStream.getTracks().forEach(track => {
                        pc.addTrack(track, localStream);
                    });
                } catch (err) {
                    alert("Microphone access denied! " + err.message);
                    return;
                }
            }

            isMicOn = !isMicOn;
            localStream.getAudioTracks()[0].enabled = isMicOn; // Mute / Unmute

            if (isMicOn) {
                btn.classList.add('active');
                btn.innerHTML = '<i class="fas fa-microphone"></i>';
                stat.innerText = "Live Chat";
                stat.style.color = "var(--accent)";
            } else {
                btn.classList.remove('active');
                btn.innerHTML = '<i class="fas fa-microphone-slash"></i>';
                stat.innerText = "Voice Off";
                stat.style.color = "var(--text-sec)";
            }
        };

        // Receive Remote Audio
        const remoteAudio = document.getElementById('remote-audio');
        pc.ontrack = (event) => {
            if(remoteAudio.srcObject !== event.streams[0]) {
                remoteAudio.srcObject = event.streams[0];
                remoteAudio.play().catch(e => console.log("Autoplay prevented:", e));
            }
        };

        // WebRTC Signaling (Host creates Offer)
        async function setupWebRTCOffer(roomRef) {
            const callerCandidates = collection(roomRef, "callerCandidates");
            pc.onicecandidate = event => {
                if (event.candidate) addDoc(callerCandidates, event.candidate.toJSON());
            };

            const offerDescription = await pc.createOffer();
            await pc.setLocalDescription(offerDescription);

            await updateDoc(roomRef, { offer: { type: offerDescription.type, sdp: offerDescription.sdp } });

            // Listen for Answer
            onSnapshot(roomRef, (snapshot) => {
                const data = snapshot.data();
                if (!pc.currentRemoteDescription && data && data.answer) {
                    const answerDescription = new RTCSessionDescription(data.answer);
                    pc.setRemoteDescription(answerDescription);
                }
            });

            // Listen for Remote ICE Candidates
            onSnapshot(collection(roomRef, "calleeCandidates"), snapshot => {
                snapshot.docChanges().forEach(change => {
                    if (change.type === "added") {
                        let candidate = new RTCIceCandidate(change.doc.data());
                        pc.addIceCandidate(candidate);
                    }
                });
            });
        }

        // WebRTC Signaling (Guest creates Answer)
        async function setupWebRTCAnswer(roomRef) {
            const roomSnap = await getDoc(roomRef);
            const data = roomSnap.data();
            
            if(!data.offer) return; // Wait for offer if not ready

            const calleeCandidates = collection(roomRef, "calleeCandidates");
            pc.onicecandidate = event => {
                if (event.candidate) addDoc(calleeCandidates, event.candidate.toJSON());
            };

            const offerDescription = new RTCSessionDescription(data.offer);
            await pc.setRemoteDescription(offerDescription);

            const answerDescription = await pc.createAnswer();
            await pc.setLocalDescription(answerDescription);

            await updateDoc(roomRef, { answer: { type: answerDescription.type, sdp: answerDescription.sdp } });

            // Listen for Remote ICE Candidates
            onSnapshot(collection(roomRef, "callerCandidates"), snapshot => {
                snapshot.docChanges().forEach(change => {
                    if (change.type === "added") {
                        let candidate = new RTCIceCandidate(change.doc.data());
                        pc.addIceCandidate(candidate);
                    }
                });
            });
        }

        // ==========================================
        // 5. LEAVE GAME ROUTING
        // ==========================================
        window.leaveGame = () => {
            if(confirm("Exit the game room?")) {
                if(localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                }
                pc.close();
                window.parent.postMessage("leave_game", "*");
            }
        };
    </script>
</body>
</html>
